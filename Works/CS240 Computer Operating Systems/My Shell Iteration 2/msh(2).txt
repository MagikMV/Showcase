/* msh.c   [my shell]
 *
 * Miguel Villanueva
 * CS 240
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>

// ----------------------------------------- //
//    Queue
//  =========
typedef struct Node
{
    void *data;
    struct Node *next;
}Node;
typedef struct Queue
{
    struct Node *front;
    struct Node *last;
    unsigned int size;
}Queue;

void Init(Queue *q);
char *front(Queue *q);
void pop(Queue *q);
void push(Queue *q, void *data);
int getQueueSize(Queue *q);
// ......................................... //
//    Definitions
//  ===============

//  Initialize the queue
void Init(Queue *q)
{
    q->front = NULL;
    q->last = NULL;
    q->size = 0;
}

//  Return data at front of queue
char *front(Queue *q)
{
    return q->front->data;
}

//  Remove front of queue
void Dequeue(Queue *q)
{
    //  Decrease size of queue
    q->size--;

    Node *t = q->front;
    q->front = q->front->next;
    free(t);
}

//  Add to queue
void Enqueue(Queue *q, void *data)
{
    //  Increase size of queue
    q->size++;

    //  Empty case
    if(q->front == NULL)
    {
        q->front = (Node *)malloc(sizeof(Node));
        q->front->data = data;
        q->front->next = NULL;
        q->last = q->front;
    }
    else
    {
        q->last->next = (Node *)malloc(sizeof(Node));
        q->last->next->data = data;
        q->last->next->next = NULL;
        q->last = q->last->next;
    }
}

//  Return queue size
int getQueueSize(Queue *q)
{
    return q->size;
}

/*//===================================================//
// prototypes
int makearg(char s[], char ***args);
int count(char *s);
int execute(char **args);

int main()
{
    int i;
    int histcount = 0;
    int aliascount = 0;
    char **argv;
    char **history = NULL;
    char input_line[256];
    char filecmd[256];
    char *alias[4];
    char *acmd[4];
    char *sToken;
    char *temp;
    FILE *f;
    Queue exec_queue;

    // initialize execution queue
    Init(&exec_queue);

    // loop shell
    while(1)
    {
        // take input
        printf("?: ");
        fgets(input_line, sizeof(input_line), stdin);

        // readfile command
        if(strstr(input_line, "readfile") != NULL)
        {
        if(strstr(input_line, "readfile") != NULL)
        {
            if ((f = fopen("mshrc", "r")) == NULL)
            {
                printf("Failed to open 'mshrc' file");
            }
            // get each line
            while (fgets(filecmd, sizeof(filecmd), f) != NULL)
            {
                filecmd[strlen(filecmd)] = '\0';
                // add the line into the execution queue
                Enqueue(&exec_queue, filecmd);
            }
            fclose(f);
        }

        // alias command
        if (strstr(input_line, "alias") != NULL)
        {
            // check if limit reached
            if(aliascount < 5)
            {
                // store the command
                temp = strtok(input_line,"=");
                acmd[aliascount] = strtok (NULL, "=");
                // store the alias name
                temp = strtok(temp," ");
                alias[aliascount] = strtok(NULL," ");
                aliascount++;
            }
            else
            {
                printf("Alias limit reached\n");
                printf("Previous aliases will be overwritten\n");
                aliascount = 0;
            }
                aliascount = 0;
            }
        }

        // separate commands
        sToken = strtok(input_line, ";");
        while (sToken != NULL)
        {
            // check for alias match
            for(i = 0; i < 4; i++)
            {
                if(aliascount > 0 && strstr(sToken, alias[i]) != NULL)
                {
                    // add alias command into queue
                    Enqueue(&exec_queue, acmd[i]);
                }
            }
            // add command to execution queue
            Enqueue(&exec_queue, sToken);
            sToken = strtok(NULL, ";");
        }

        // while there are commands in the queue
        while(getQueueSize(&exec_queue) > 0)
        {
            // allocate and add the command to history
            history = (char **)realloc(history, (histcount + 1) * sizeof(char *));
            if(front(&exec_queue) != NULL)
            {
                history[histcount++] = strdup(front(&exec_queue));
            }

            // format command
            makearg(front(&exec_queue), &argv);

            // exit command
            if(strcmp(argv[0], "exit")==0)
            {
                exit(0);
            }

            // check for history commands
            if(strcmp(argv[0], "history")==0)
            {
                printf("History:\n");
                // only display 20 items
                if(histcount > 20)
                {
                    for(i = histcount - 20; i < histcount; i++)
                    {
                        printf("%d: %s", i, history[i]);
                    }
                }
                else
                {
                    for(i = 0; i < histcount; i++)
                    {
                        printf("%d: %s", i, history[i]);
                    }
                }
            }
            if(strstr(argv[0], "!") != NULL)
            {
                // execute last command
                if(strcmp(argv[0], "!!")==0)
                {
                    makearg(history[histcount-2], &argv);
                }
                else
                {
                    // add command from specified index
                    makearg(history[atoi(strtok(input_line,"!"))], &argv);
                }
            }

            // execute the command
            execute(argv);
            // remove it from the execution queue
            Dequeue(&exec_queue);
        }
    }

    return 0;
}

// create argument structure
int makearg(char s[], char ***args)
{
    int wordcount;
    int length;

    // get the word count
    wordcount = count(s);
    // allocate
    *args = malloc(wordcount * sizeof(char*));
    if(args == NULL)
    {
        return -1;
    }

    // reset count
    wordcount = 0;

    // while string
    while(*s)
    {
        // skip over space
        while(isspace(*s))
        {
            ++s;
        }

        // check for end of file and calculate length
        if(EOF==sscanf(s, "%*s%n", &length))
        {
            break;
        }

        // allocate
        (*args)[wordcount] = malloc(length + 1);

        // copy the string over
        strncpy((*args)[wordcount], s, length);
        // terminate it
        (*args)[wordcount++][length] = '\0';
        s += length;
    }
    return wordcount;
}

// count the words in the string
int count(char *s)
{
    int wordcount = 0;
    char first = ' ';

    // determine word count
    while(*s)
    {
        // if the space is after the first word
        if(!isspace(*s) && isspace(first))
        {
            ++wordcount;
        }
        first = *s++;
    }
    return wordcount;
}

// execute
int execute(char **args)
{
    pid_t childpid;
    int status;

    // create the fork
    if ((childpid = fork()) == -1)
    {
        perror("Fork error");
        exit(1);
    }
    else if (childpid == 0)
    {
        // execute it
        if (execvp(args[0], args) < 0)
        {
            perror("Execution failed");
            exit(1);
        }
    }
    else if (childpid != wait(&status))
    {
        perror("A signal occurred before the child exited");
        exit(1);
    }
}
//===================================================//*/
